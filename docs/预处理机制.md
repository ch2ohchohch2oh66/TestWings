# 预处理机制

> 预处理机制设计文档 - 基于AI大模型的智能识别和匹配方案

## 一、设计理念

### 1.1 核心思想

**所见即所测 + AI智能识别 = 简单高效**

预处理机制是一个**可选的性能优化方案**，用于减少实时图像识别请求，降低性能开销，提升执行效率。如果Vision-Language模型足够高效准确，预处理也可以不实现。

**核心原则**：
- **简单命名**：测试工程师只需提供截图和简单的文件名，无需填写复杂的元数据
- **AI自动识别**：由AI大模型自动识别截图内容，生成结构化数据
- **智能匹配**：大模型基于自己的理解，将用例中的页面和场景与预处理截图智能关联
- **充分使用大模型能力**：利用大模型的自然语言识别、推导能力，像手动操作一样完成自动化测试

### 1.2 方案定位

**预处理机制是性能优化方案，不是必需功能**：

- ✅ **如果VL模型足够高效准确**：可以完全依赖实时识别，不需要预处理
- ✅ **如果需要提升性能**：可以使用预处理机制，减少实时识别请求
- ✅ **如果VL模型性能不足**：预处理机制可以显著提升执行速度

### 1.3 工作流程

**测试工程师**：
1. 准备页面截图（按命名规范）
2. 提交预处理请求（无需填写元数据）

**系统**：
1. 接收截图
2. **AI大模型自动识别**：VL模型分析截图，自动生成结构化数据
3. **AI智能生成元数据**：大模型根据图像识别结果，智能生成元数据
4. 存储预处理结果
5. 执行时智能匹配使用

---

## 二、文件命名规范

### 2.1 命名格式

**文件命名格式**：
```
APPNAME_页面名_场景名.png
```

**命名规则**：
- 使用中文或英文
- 使用下划线 `_` 分隔不同部分
- 场景名可选，如有多个场景则必须提供
- 支持多级场景，用下划线分隔

### 2.2 命名示例

**基础页面**：
```
微信_登录页面.png
微信_微信页面.png
微信_通讯录页面.png
微信_我页面.png
```

**多场景页面**：
```
微信_通讯录页面_默认.png
微信_通讯录页面_空列表.png
微信_通讯录页面_搜索.png
```

**多级场景**：
```
微信_我页面_设置.png
微信_我页面_设置_个人资料.png
微信_我页面_设置_账号与安全.png
微信_我页面_设置_账号与安全_修改密码.png
```

**其他应用示例**：
```
会议_加入房间.png
会议_录制中.png
会议_录制中_暂停.png
```

### 2.3 命名建议

**建议**：
- **清晰明确**：页面名称和场景名称要清晰明确，便于AI理解
- **自然语言**：使用自然的中文或英文描述，符合日常使用习惯
- **层次分明**：多级场景使用下划线分隔，层次清晰
- **一致性**：同一应用的命名风格保持一致

**注意事项**：
- 不需要版本号（由AI自动识别页面变化）
- 不需要小写转换（支持中文和英文混合）
- 不需要复杂的编码规则（自然语言即可）

---

## 三、AI自动识别和元数据生成

### 3.1 自动识别流程

```
测试工程师提交截图
  ↓
Vision-Language模型分析截图
  ├─ 识别所有文字内容
  ├─ 识别所有UI元素（按钮、输入框、图标等）
  ├─ 理解页面布局和结构
  └─ 理解页面语义和功能
  ↓
LLM智能生成元数据
  ├─ 根据VL识别结果，生成页面描述
  ├─ 提取关键特征（关键文字、关键元素）
  ├─ 理解页面功能和使用场景
  └─ 生成结构化元数据
  ↓
存储预处理结果
  ├─ 页面标识（基于文件名和AI理解）
  ├─ 元素列表（VL识别结果）
  └─ 元数据（AI智能生成）
```

### 3.2 AI生成的元数据结构

**AI自动生成的元数据示例**：
```json
{
  "page_id": "微信_登录页面",
  "app_name": "微信",
  "app_display_name": "微信",
  "page_name": "登录页面",
  "page_display_name": "登录页面",
  "scenario_name": null,
  "scenario_display_name": null,
  "description": "微信登录页面，包含账号输入框、密码输入框、登录按钮",
  "key_features": {
    "key_texts": ["微信", "登录", "账号", "密码"],
    "key_elements": ["账号输入框", "密码输入框", "登录按钮"]
  },
  "elements": [
    {
      "type": "input",
      "text": "账号",
      "position": {"x": 100, "y": 300, "width": 500, "height": 60},
      "confidence": 0.95
    },
    {
      "type": "input",
      "text": "密码",
      "position": {"x": 100, "y": 400, "width": 500, "height": 60},
      "confidence": 0.94
    },
    {
      "type": "button",
      "text": "登录",
      "position": {"x": 300, "y": 500, "width": 200, "height": 50},
      "confidence": 0.96
    }
  ],
  "screenshot_type": "static",
  "created_at": "2024-01-01T10:00:00Z",
  "generated_by": "AI"
}
```

**关键点**：
- ✅ **完全由AI生成**：测试工程师无需填写任何元数据
- ✅ **基于图像理解**：元数据基于VL模型的图像识别结果
- ✅ **智能语义理解**：LLM理解页面语义，生成准确的描述

### 3.3 多场景识别

**AI自动识别多场景示例**：

**文件**：`微信_通讯录页面_空列表.png`

**AI生成的元数据**：
```json
{
  "page_id": "微信_通讯录页面_空列表",
  "app_name": "微信",
  "page_name": "通讯录页面",
  "scenario_name": "空列表",
  "scenario_display_name": "空列表",
  "description": "微信通讯录页面，当前为空列表状态，显示'暂无联系人'提示",
  "key_features": {
    "key_texts": ["通讯录", "暂无联系人"],
    "key_elements": ["空列表提示", "添加联系人按钮"]
  }
}
```

**AI识别逻辑**：
- VL模型识别到"暂无联系人"文字 → 判断为空列表场景
- LLM理解场景语义 → 生成场景描述
- 自动关联文件名中的场景名 → 生成完整元数据

---

## 四、智能匹配机制

### 4.1 匹配流程

```
用例执行
  ↓
用例中的页面描述（自然语言）
  ├─ "打开微信，进入登录页面"
  ├─ "进入通讯录页面"
  └─ "打开设置，进入个人资料"
  ↓
LLM理解用例描述
  ├─ 提取应用名称：微信
  ├─ 提取页面名称：登录页面、通讯录页面、个人资料
  └─ 提取场景信息（如有）
  ↓
智能匹配预处理截图
  ├─ 文件名匹配：查找包含"微信_登录页面"的截图
  ├─ 语义匹配：LLM理解"登录页面"和预处理截图的语义关联
  └─ 特征匹配：比较关键特征（关键文字、关键元素）
  ↓
匹配成功：使用预处理结果
匹配失败：实时VL识别
```

### 4.2 匹配策略

**匹配优先级**：

1. **文件名匹配**（优先）
   - 用例："进入登录页面"
   - 匹配：查找文件名包含"登录页面"的预处理截图
   - 示例：`微信_登录页面.png` ✅

2. **语义匹配**（主要能力）
   - 用例："打开微信登录界面"
   - LLM理解："登录界面" = "登录页面"
   - 匹配：`微信_登录页面.png` ✅

3. **特征匹配**（降级方案）
   - 用例："进入需要输入账号密码的页面"
   - 特征匹配：比较关键特征（账号输入框、密码输入框）
   - 匹配：`微信_登录页面.png` ✅

### 4.3 匹配示例

**示例1：基础匹配**

**用例**（自然语言）：
```
打开微信，进入登录页面
```

**预处理截图**：
- `微信_登录页面.png`

**匹配过程**：
1. LLM理解用例："登录页面"
2. 文件名匹配：找到 `微信_登录页面.png`
3. 匹配成功 ✅

**示例2：语义匹配**

**用例**（自然语言）：
```
打开微信，进入登录界面
```

**预处理截图**：
- `微信_登录页面.png`

**匹配过程**：
1. LLM理解用例："登录界面"
2. LLM语义理解："登录界面" ≈ "登录页面"
3. 语义匹配：找到 `微信_登录页面.png`
4. 匹配成功 ✅

**示例3：多场景匹配**

**用例**（自然语言）：
```
打开微信，进入通讯录，查看空列表
```

**预处理截图**：
- `微信_通讯录页面_空列表.png`
- `微信_通讯录页面_默认.png`

**匹配过程**：
1. LLM理解用例："通讯录" + "空列表"
2. 文件名匹配：找到 `微信_通讯录页面_空列表.png`
3. 匹配成功 ✅

**示例4：多级场景匹配**

**用例**（自然语言）：
```
打开微信，进入"我"页面，打开设置，进入个人资料
```

**预处理截图**：
- `微信_我页面_设置_个人资料.png`

**匹配过程**：
1. LLM理解用例："我" + "设置" + "个人资料"
2. 文件名匹配：找到 `微信_我页面_设置_个人资料.png`
3. 匹配成功 ✅

---

## 五、预处理流程

### 5.1 预处理阶段

```
1. 测试工程师准备截图
   ├─ 打开APP，导航到目标页面
   ├─ 截图保存
   └─ 按命名规范命名：APPNAME_页面名_场景名.png
   ↓
2. 提交预处理请求
   ├─ 上传截图文件
   └─ 无需填写元数据
   ↓
3. AI大模型自动识别
   ├─ Vision-Language模型分析截图
   │   ├─ 识别所有文字内容
   │   ├─ 识别所有UI元素
   │   └─ 理解页面布局和语义
   ├─ LLM智能生成元数据
   │   ├─ 根据VL识别结果，生成页面描述
   │   ├─ 提取关键特征
   │   └─ 生成结构化元数据
   └─ 解析文件名
   │   ├─ 提取应用名称
   │   ├─ 提取页面名称
   │   └─ 提取场景名称（如有）
   ↓
4. 存储预处理结果
   ├─ 页面标识（基于文件名和AI理解）
   ├─ 元素列表（VL识别结果）
   └─ 元数据（AI智能生成）
```

### 5.2 执行阶段

```
执行测试步骤
  ↓
用例中的页面描述（自然语言）
  ↓
LLM理解用例描述
  ├─ 提取应用名称
  ├─ 提取页面名称
  └─ 提取场景信息（如有）
  ↓
智能匹配预处理截图
  ├─ 文件名匹配
  ├─ 语义匹配（LLM理解）
  └─ 特征匹配（降级）
  ↓
匹配结果
  ├─ 匹配成功：使用预处理结果（快速）
  └─ 未匹配：实时VL识别（VL为主，OCR为辅）
  ↓
执行操作
```

---

## 六、技术可行性分析

### 6.1 技术可行性

**✅ 完全可行**，基于以下技术基础：

1. **Vision-Language模型能力**
   - VL模型（如Qwen-VL、GPT-4V）可以理解图像内容
   - 可以识别文字、UI元素、布局结构
   - 可以理解页面语义和功能

2. **LLM自然语言理解能力**
   - LLM可以理解自然语言描述
   - 可以理解语义关联（如"登录界面" = "登录页面"）
   - 可以智能匹配和推理

3. **成功范例**
   - **豆包手机助手**：基于VL理解屏幕，LLM理解指令，完全自动化
   - **其他AI自动化工具**：也是基于大模型的自然语言理解

### 6.2 方案优势

**方案特点**：

- **文件命名**：简单自然（中文、自然语言）
- **元数据**：AI自动生成
- **匹配方式**：语义匹配（智能）
- **测试工程师工作量**：低（只需截图和命名）
- **维护成本**：低（AI自动识别）

### 6.3 实施建议

**阶段1：基础实现**
- 实现VL模型自动识别截图
- 实现LLM智能生成元数据
- 实现文件名解析

**阶段2：智能匹配**
- 实现文件名匹配
- 实现语义匹配（LLM理解）
- 实现特征匹配（降级）

**阶段3：性能优化**
- 优化预处理速度
- 优化匹配速度
- 优化缓存机制

---

## 七、预处理作为性能优化

### 7.1 方案定位

**预处理机制是性能优化方案，不是必需功能**：

- ✅ **如果VL模型足够高效准确**：可以完全依赖实时识别，不需要预处理
- ✅ **如果需要提升性能**：可以使用预处理机制，减少实时识别请求
- ✅ **如果VL模型性能不足**：预处理机制可以显著提升执行速度

### 7.2 性能特点

**预处理方案性能**：
- 预处理一次，多次使用
- 响应时间：< 100ms（直接使用缓存）
- 资源占用：预处理时占用资源，执行时几乎无占用

### 7.3 适用场景

**适合使用预处理的情况**：
- VL模型推理速度较慢（> 3秒）
- 需要频繁执行相同页面的测试
- 需要离线执行测试
- 需要提升整体执行效率

**适合使用实时识别的情况**：
- VL模型推理速度足够快（< 1秒）
- 页面变化频繁
- 测试场景多样化
- 资源充足

---

## 八、测试工程师工作流程

### 8.1 准备预处理截图

**步骤**（非常简单）：
1. 打开待测APP，导航到目标页面
2. 截图保存
3. 按命名规范命名：`APPNAME_页面名_场景名.png`
4. 提交预处理请求（无需填写元数据）

**示例**：
```
1. 打开微信，进入登录页面
2. 截图保存为：微信_登录页面.png
3. 提交预处理请求
4. AI自动识别并生成元数据
```

### 8.2 命名建议

**建议**：
- **使用自然语言**：使用日常使用的页面名称，如"登录页面"、"通讯录页面"
- **清晰明确**：页面名称要清晰明确，便于AI理解
- **场景区分**：如有多个场景，使用场景名区分，如"空列表"、"搜索"
- **多级场景**：使用下划线分隔多级场景，如"设置_个人资料"

**示例**：
- `微信_登录页面.png` - 清晰明确
- `微信_通讯录页面_空列表.png` - 场景区分
- `微信_我页面_设置_个人资料.png` - 多级场景

---

## 九、常见问题

### 9.1 文件命名不一致怎么办？

**问题**：用例中写"登录界面"，预处理截图是"登录页面"

**解决**：
- ✅ **AI语义匹配**：LLM理解"登录界面" ≈ "登录页面"，自动匹配
- ✅ **无需修改**：测试工程师无需修改文件名或用例

### 9.2 页面更新后如何处理？

**问题**：页面UI更新后，预处理结果可能失效

**解决**：
- ✅ **AI自动检测**：VL模型识别页面变化，自动重新预处理
- ✅ **降级策略**：预处理失效时自动降级到实时识别
- ✅ **无需手动更新**：AI自动处理，测试工程师无需干预

### 9.3 用例匹配失败怎么办？

**问题**：用例中的页面描述无法匹配预处理截图

**解决**：
- ✅ **自动降级**：匹配失败时自动使用实时VL识别
- ✅ **不影响执行**：预处理是优化方案，不是必需功能
- ✅ **AI学习**：系统可以学习匹配失败的原因，优化匹配策略

---

## 十、总结

### 10.1 核心优势

**AI智能预处理方案的核心优势**：

1. **简单易用**：测试工程师只需截图和简单命名，无需填写复杂元数据
2. **智能识别**：AI自动识别截图内容，生成结构化数据
3. **智能匹配**：AI理解自然语言，智能匹配用例和预处理截图
4. **充分使用大模型能力**：利用大模型的自然语言识别、推导能力
5. **所见即所测**：像手动操作一样完成自动化测试

### 10.2 方案定位

**预处理机制是性能优化方案**：
- ✅ 如果VL模型足够高效准确，可以不需要预处理
- ✅ 如果需要提升性能，可以使用预处理机制
- ✅ 预处理是可选功能，不影响核心功能

### 10.3 技术可行性

**✅ 完全可行**，基于：
- Vision-Language模型的图像理解能力
- LLM的自然语言理解能力
- 已有成功范例（如豆包手机助手）

### 10.4 关键要点

1. **文件命名**：`APPNAME_页面名_场景名.png`，使用自然语言
2. **AI自动识别**：无需填写元数据，AI自动识别和生成
3. **智能匹配**：AI理解自然语言，智能匹配用例和预处理截图
4. **性能优化**：预处理是可选优化方案，不是必需功能

遵循这些原则，可以实现简单、智能、高效的预处理机制，充分使用大模型能力，实现"所见即所测"的自动化测试。
